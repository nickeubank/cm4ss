<!DOCTYPE html> <html lang=en  data-content_root="./"> <meta charset=utf-8  /> <meta name=viewport  content="width=device-width, initial-scale=1.0" /><meta name=viewport  content="width=device-width, initial-scale=1" /> <meta name=viewport  content="width=device-width,initial-scale=1"> <meta http-equiv=x-ua-compatible  content="ie=edge"> <meta name="lang:clipboard.copy" content="Copy to clipboard"> <meta name="lang:clipboard.copied" content="Copied to clipboard"> <meta name="lang:search.language" content=en > <meta name="lang:search.pipeline.stopwords" content=True > <meta name="lang:search.pipeline.trimmer" content=True > <meta name="lang:search.result.none" content="No matching documents"> <meta name="lang:search.result.one" content="1 matching document"> <meta name="lang:search.result.other" content="# matching documents"> <meta name="lang:search.tokenizer" content="[\s\-]+"> <link href="https://fonts.gstatic.com/" rel=preconnect  crossorigin> <link href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,500,700|Roboto:300,400,400i,700&display=fallback" rel=stylesheet > <style> body, input { font-family: "Roboto", "Helvetica Neue", Helvetica, Arial, sans-serif } code, kbd, pre { font-family: "Roboto Mono", "Courier New", Courier, monospace } </style> <link rel=stylesheet  href="_static/stylesheets/application.css"/> <link rel=stylesheet  href="_static/stylesheets/application-palette.css"/> <link rel=stylesheet  href="_static/stylesheets/application-fixes.css"/> <link rel=stylesheet  href="_static/fonts/material-icons.css"/> <meta name=theme-color  content="#012169"> <script src="_static/javascripts/modernizr.js"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-203713456-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag() { dataLayer.push(arguments); } gtag('js', new Date()); gtag('config', 'UA-203713456-1'); </script> <title>Devising an Algorithm: Steps 1-4 &#8212; Computational Methods for Social Scientists</title> <link rel=stylesheet  type="text/css" href="_static/pygments.css?v=649a27d8" /> <link rel=stylesheet  type="text/css" href="_static/material.css?v=79c92029" /> <script src="_static/documentation_options.js?v=5929fcd5"></script> <script src="_static/doctools.js?v=888ff710"></script> <script src="_static/sphinx_highlight.js?v=dc90522c"></script> <script crossorigin=anonymous  integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script> <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script> <script defer=defer  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script> <link rel=icon  href="_static/mids_logo.svg"/> <link rel=index  title=Index  href=genindex.html  /> <link rel=search  title=Search  href=search.html  /> <body dir=ltr data-md-color-primary=blue-grey data-md-color-accent=blue> <svg class=md-svg > <defs data-children-count=0 > <svg xmlns="http://www.w3.org/2000/svg" width=416  height=448  viewBox="0 0 416 448" id=__github ><path fill=currentColor  d="M160 304q0 10-3.125 20.5t-10.75 19T128 352t-18.125-8.5-10.75-19T96 304t3.125-20.5 10.75-19T128 256t18.125 8.5 10.75 19T160 304zm160 0q0 10-3.125 20.5t-10.75 19T288 352t-18.125-8.5-10.75-19T256 304t3.125-20.5 10.75-19T288 256t18.125 8.5 10.75 19T320 304zm40 0q0-30-17.25-51T296 232q-10.25 0-48.75 5.25Q229.5 240 208 240t-39.25-2.75Q130.75 232 120 232q-29.5 0-46.75 21T56 304q0 22 8 38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0 37.25-1.75t35-7.375 30.5-15 20.25-25.75T360 304zm56-44q0 51.75-15.25 82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5T212 416q-19.5 0-35.5-.75t-36.875-3.125-38.125-7.5-34.25-12.875T37 371.5t-21.5-28.75Q0 312 0 260q0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25 30.875Q171.5 96 212 96q37 0 70 8 26.25-20.5 46.75-30.25T376 64q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34 99.5z"/></svg> </defs> </svg> <input class=md-toggle  data-md-toggle=drawer  type=checkbox  id=__drawer > <input class=md-toggle  data-md-toggle=search  type=checkbox  id=__search > <label class=md-overlay  data-md-component=overlay  for=__drawer ></label> <a href="#seven_steps_1_4" tabindex=1  class=md-skip > Skip to content </a> <header class=md-header  data-md-component=header > <nav class="md-header-nav md-grid"> <div class="md-flex navheader"> <div class="md-flex__cell md-flex__cell--shrink"> <a href=index.html  title="Computational Methods for Social Scientists" class="md-header-nav__button md-logo"> &nbsp; </a> </div> <div class="md-flex__cell md-flex__cell--shrink"> <label class="md-icon md-icon--menu md-header-nav__button" for=__drawer ></label> </div> <div class="md-flex__cell md-flex__cell--stretch"> <div class="md-flex__ellipsis md-header-nav__title" data-md-component=title > <span class=md-header-nav__topic >Computational Methods for Social Scientists</span> <span class=md-header-nav__topic > Devising an Algorithm: Steps 1-4 </span> </div> </div> <div class="md-flex__cell md-flex__cell--shrink"> <label class="md-icon md-icon--search md-header-nav__button" for=__search ></label> <div class=md-search  data-md-component=search  role=dialog > <label class=md-search__overlay  for=__search ></label> <div class=md-search__inner  role=search > <form class=md-search__form  action=search.html  method=get  name=search > <input type=text  class=md-search__input  name=q  placeholder=""Search"" autocapitalize=off  autocomplete=off  spellcheck=false  data-md-component=query  data-md-state=active > <label class="md-icon md-search__icon" for=__search ></label> <button type=reset  class="md-icon md-search__icon" data-md-component=reset  tabindex=-1 > &#xE5CD; </button> </form> <div class=md-search__output > <div class=md-search__scrollwrap  data-md-scrollfix> <div class=md-search-result  data-md-component=result > <div class=md-search-result__meta > Type to start searching </div> <ol class=md-search-result__list ></ol> </div> </div> </div> </div> </div> </div> <script src="_static/javascripts/version_dropdown.js"></script> <script> var json_loc = ""versions.json"", target_loc = "../", text = "Versions"; $( document ).ready( add_version_dropdown(json_loc, target_loc, text)); </script> </div> </nav> </header> <div class=md-container > <nav class=md-tabs  data-md-component=tabs > <div class="md-tabs__inner md-grid"> <ul class=md-tabs__list > <li class=md-tabs__item ><a href=index.html  class=md-tabs__link >Home</a> <li class=md-tabs__item ><a href=class_schedule_fall.html  class=md-tabs__link >Class Schedule (Fall 2023)</a> <li class=md-tabs__item ><a href=class_schedule_winter.html  class=md-tabs__link >Class Schedule (Winter 2024)</a> <li class=md-tabs__item ><a href="https://www.nickeubank.com" class=md-tabs__link >About The Author</a> </ul> </div> </nav> <main class=md-main > <div class="md-main__inner md-grid" data-md-component=container > <div class="md-sidebar md-sidebar--primary" data-md-component=navigation > <div class=md-sidebar__scrollwrap > <div class=md-sidebar__inner > <nav class="md-nav md-nav--primary" data-md-level=0 > <label class="md-nav__title md-nav__title--site" for=__drawer > <a href=index.html  title="Computational Methods for Social Scientists" class="md-nav__button md-logo"> <img src="_static/" alt=" logo" width=48  height=48 > </a> <a href=index.html  title="Computational Methods for Social Scientists">Computational Methods for Social Scientists</a> </label> <ul class=md-nav__list > <li class=md-nav__item > <a href=class_schedule_fall.html  class=md-nav__link >Class Schedule (August 2024)</a> <li class=md-nav__item > <a href=class_schedule_winter.html  class=md-nav__link >Class Schedule (January 2024)</a> <li class=md-nav__item > <span class="md-nav__link caption"><span class=caption-text >Class Readings</span></span> <li class=md-nav__item > <a href=intro_to_r.html  class=md-nav__link >Intro to R</a> <li class=md-nav__item > <a href=intro_to_datatypes.html  class=md-nav__link >Intro to Data Types</a> <li class=md-nav__item > <a href=intro_to_vectors.html  class=md-nav__link >Intro to Vectors</a> <li class=md-nav__item > <a href=manipulating_vectors.html  class=md-nav__link >Manipulating Vectors</a> <li class=md-nav__item > <a href=intro_to_matrices.html  class=md-nav__link >Intro to Matrices</a> <li class=md-nav__item > <a href=manipulating_matrices.html  class=md-nav__link >Manipulating Matrices</a> <li class=md-nav__item > <a href=intro_to_dataframes.html  class=md-nav__link >Intro to Dataframes</a> <li class=md-nav__item > <a href=manipulating_dataframes.html  class=md-nav__link >Manipulating Dataframes</a> <li class=md-nav__item > <a href=intro_to_tidyverse.html  class=md-nav__link >dplyr and the Tidyverse</a> <li class=md-nav__item > <a href=defensive_programming.html  class=md-nav__link >Defensive Programming</a> <li class=md-nav__item > <a href=intro_to_merging.html  class=md-nav__link >Intro to Merging</a> <li class=md-nav__item > <a href=defensive_merging.html  class=md-nav__link >Defensive Merging</a> <li class=md-nav__item > <a href=missing_data.html  class=md-nav__link >Missing Data</a> <li class=md-nav__item > <a href=loops.html  class=md-nav__link >Loops</a> <li class=md-nav__item > <a href=functions.html  class=md-nav__link >Functions</a> <li class=md-nav__item > <a href=function_example.html  class=md-nav__link >Function Example</a> <li class=md-nav__item > <span class="md-nav__link caption"><span class=caption-text >Additional Topics</span></span> <li class=md-nav__item > <a href=lists.html  class=md-nav__link >Lists</a> </ul> </nav> </div> </div> </div> <div class="md-sidebar md-sidebar--secondary" data-md-component=toc > <div class=md-sidebar__scrollwrap > <div class=md-sidebar__inner > <nav class="md-nav md-nav--secondary"> <label class=md-nav__title  for=__toc >"Contents"</label> <ul class=md-nav__list  data-md-scrollfix=""> <li class=md-nav__item ><a href="#seven-steps-1-4--page-root" class=md-nav__link >Devising an Algorithm: Steps 1-4</a><nav class=md-nav > <ul class=md-nav__list > <li class=md-nav__item ><a href="#What-Is-An-Algorithm" class=md-nav__link >What Is An Algorithm</a> <li class=md-nav__item ><a href="#Stepping-Through-an-Algorithm-By-Hand" class=md-nav__link >Stepping Through an Algorithm By Hand</a> <li class=md-nav__item ><a href="#Step-1:-Work-an-Example-Yourself" class=md-nav__link >Step 1: Work an Example Yourself</a> <li class=md-nav__item ><a href="#Step-2:-Write-Down-What-You-Just-Did" class=md-nav__link >Step 2: Write Down What You Just Did</a> <li class=md-nav__item ><a href="#Step-3:-Generalize-Your-Steps" class=md-nav__link >Step 3: Generalize Your Steps</a> <li class=md-nav__item ><a href="#Step-4:-Test-Your-Algorithm" class=md-nav__link >Step 4: Test Your Algorithm</a> </ul> </nav> </ul> </nav> </div> </div> </div> <div class=md-content > <article class="md-content__inner md-typeset" role=main > <section id="Devising-an-Algorithm:-Steps-1-4"> <h1 id=seven-steps-1-4--page-root >Devising an Algorithm: Steps 1-4<a class=headerlink  href="#seven-steps-1-4--page-root" title="Link to this heading">¶</a></h1> <blockquote> <div><p>These 7 steps — and all the material that follows — was created by Drew Hilton, Anne Bracy, and Genevieve Lipp, and has been subject to only a few minor modifications by myself (Nick Eubank) for use in this bootcamp.</p> </div></blockquote> <section id=What-Is-An-Algorithm > <h2 id=What-Is-An-Algorithm >What Is An Algorithm<a class=headerlink  href="#What-Is-An-Algorithm" title="Link to this heading">¶</a></h2> <p>As we discussed earlier, an algorithm is a clear set of steps to solve any problem in a particular class. Typically, algorithms have at least one parameter; however, algorithms with no parameters exist—they are simply restricted to one specific problem, rather than a more general class. We can discuss and think about algorithms in the absence of any particular knowledge of computers—a good algorithm can not only be translated into code, but could also be executed by a person with no particular knowledge of the problem at hand.</p> <p>Algorithms that computers work on deal with numbers—in fact the lesson on Types will discuss the concept of “Everything is a number,” which is a key principle in programming. Computers can only compute on numbers; however, this course will also illustrate how we can represent a variety of useful things (letters, words, images, videos, sound, etc.) as numbers so that computers can compute on them. As a simple example of an algorithm that works with numbers, we might consider the following algorithm (which takes one parameter N, a non-negative integer):</p> <div class="highlight-none notranslate"><div class=highlight ><pre><span></span>Given a non-negative integer N:
    - Make a variable called x, set it equal to (N+2)
    - Count from 0 to N (Include both ends), and for each number (call it "i") that you count,
        -- Write down the value of (x * i)
        -- Update x to be equal to (x + i * N)
When you finish counting, write down the value of x.
</pre></div> </div> <p>For any non-negative integer N that I give you, you should be able to execute these steps. If you do these steps for <code class="docutils literal notranslate"><span class=pre >N</span> <span class=pre >=</span> <span class=pre >2</span></code>, you should come up with the sequence of numbers <code class="docutils literal notranslate"><span class=pre >0</span> <span class=pre >4</span> <span class=pre >12</span> <span class=pre >10</span></code>. These steps are unambiguous as to what should happen. It is possible that you get the wrong answer if you misunderstand the directions, or make arithmetic mistakes, but otherwise, everyone who does them for a particular value of N should get the same answer. We will also note that this algorithm can be converted into any programming language quite easily—all that is needed is to know the basic syntax of the particular language you want.</p> <p>You may wonder why we would want an algorithm that generates this particular sequence of numbers. In this case, it is just a contrived algorithm to show as a simple introductory example. In reality, we are going to devise algorithms that solve some particular problem. However, devising the algorithm for a problem takes some significant work, and will be the focus of discussion for the rest of this lesson.</p> <p>Even though computers can only work with numbers, we can envision algorithms that might be executed by humans who can work on a variety of things. For example, we might write algorithms that operate on physical objects such as LEGO bricks or food. Even though such things would be difficult to implement on a computer (we would need the computer to control a robot to actually interact with the physical world), they are still instructive, as the fundamental algorithmic design principles are the same.</p> <p>One exercise done at the start of some introductory programming courses is to have the students write down directions to make a peanut butter and jelly sandwich. The instructor then executes the algorithms, which are often imprecise and ambiguous. The instructor takes the most comical interpretation of the instructions to underscore that what the students wrote did not actually describe what they meant.</p> <p>This exercise underscores an important point—you must specify exactly what you want the computer to do. The computer does not “know what you mean” when you write something vague, nor can it figure out an “etc.” Instead, you must be able to describe exactly what you want to do in a step-by-step fashion. Precisely describing the exact steps to perform a specific task is somewhat tricky, as we are used to people implicitly understanding details we omit. The computer will not do that for you (in any programming language).</p> <p>Even though the “sandwich algorithm” exercise makes an important point about precisely describing the steps you want the computer to perform, it falls short in truly illustrating the hardest part of designing an algorithm. This algorithm has no parameters, so it just describes how to solve one particular problem (making a peanut butter and jelly sandwich). Real programming problems (typically) involve algorithms that take parameters. A more appropriate problem might be “Write an algorithm that takes a list of things you want in a sandwich and describes how to make the sandwich.”</p> <p>Such a problem is much more complex but illustrates many concepts involved in devising a real algorithm. First, our algorithm cannot take a list of just anything to include in the sandwich—it really will only work with certain types of things, namely food. We would not expect our algorithm to be able to make us a “car, skyscraper, airplane” sandwich. These items are all the wrong type. We will learn more about types in programming later in this course.</p> <p>Our algorithm may also have to deal with error cases. Even if we specify the correct type of inputs, the particular values may be impossible to operate on correctly. For example, “chicken breast” is food, but if the chicken breast has not been cooked yet, we should not try to make a sandwich out of it. Another error case in our sandwich creation algorithm might be if we specify too much food to go inside the sandwich (how do you make a sandwich with an entire turkey, 40 pounds of carrots, and 3 gallons of ice cream?). Of course, if we were writing this sandwich algorithm for humans, we could ignore this craziness because humans have “common sense”—however, computers do not.</p> <p>Even if we ignore all of the error cases, our general algorithm is not as simple as just stacking up the ingredients on top of bread in the order they appear in the input. For example, we might have an input of “chicken, mustard, spinach, tomatoes.” Here, we probably want to spread the mustard on the bread first, then place the other ingredients on it (hopefully in an order that makes the most stable sandwich).</p> <p>It would seem that writing a correct algorithm to make a sandwich from an arbitrary list of ingredients is quite a complex task. Even if we did not want to implement that algorithm in code, but rather have it be properly executed by a person with no common sense (or a professor with a comedic disregard for common sense), this task is quite challenging to do correctly. How could we go about this task and hope to get a good algorithm?</p> <p>The wrong way to write an algorithm is to just throw some stuff on the page, and then try to straighten it out later. Imagine if we approached our sandwich example by writing down some steps and having someone (with no common sense) try them out. After the kitchen catches on fire, we try to go in and figure out what went wrong. We then tweak the steps, and try again. This time, the kitchen explodes instead. We repeat this process until we finally get something that resembles a sandwich, and the house did not burn down.</p> <p>The previous paragraph may sound silly, but is exactly how many novice (and intermediate) programmers approach programming tasks. They jump right into writing code (No time to plan! Busy schedule!), and it inevitably does not work. They then pour countless hours into trying to fix the code, even though they do not have a clear plan for what it is supposed to do. As they “fix” the code, it becomes a larger, more tangled mess. Eventually, the program sort-of-kind-of works, and they call it good enough.</p> <p>Instead, you should devise an algorithm in a disciplined fashion. The above figure shows how you should approach designing your algorithm. We will spend the next few sections discussing each of these steps in detail. However, note that “translate to code” comes only after you have an algorithm that you have tested by hand—giving you some confidence that your plan is solid before you build on it.</p> <p><img alt="steps one through four" src="_images/Algorithms_flow_chart.png"/></p> <p>If you plan well enough and translate it correctly, your code will just work the first time. If it does not work the first time, you at least have a solid plan of what the code should be doing to guide your debugging.</p> </section> <section id=Stepping-Through-an-Algorithm-By-Hand > <h2 id=Stepping-Through-an-Algorithm-By-Hand >Stepping Through an Algorithm By Hand<a class=headerlink  href="#Stepping-Through-an-Algorithm-By-Hand" title="Link to this heading">¶</a></h2> <p>When we write an algorithm by hand, it should be precise enough that anyone can execute it and get exactly the right answer. You will see this in the next video. Note that once we translate algorithms to code, we will see that we can execute code by hand in much the same way.</p> <p><a class="reference external" href="https://warpwire.duke.edu/w/c8QFAA/">Please watch this video which will require a Duke login</a></p> </section> <section id="Step-1:-Work-an-Example-Yourself"> <h2 id="Step-1:-Work-an-Example-Yourself">Step 1: Work an Example Yourself<a class=headerlink  href="#Step-1:-Work-an-Example-Yourself" title="Link to this heading">¶</a></h2> <p>The first step in trying to design an algorithm is to work at least one instance of the problem—picking specific values for each parameter—yourself (by hand). Often this step will involve drawing a diagram of the problem at hand, in order to work it precisely. The more precisely you can perform this problem (including the more precisely you can draw a diagram of the situation if applicable), the easier the remainder of our steps will be. A good example of the sort of picture you might draw would be the diagrams drawn in many science classes (especially physics classes). The figure shows multiple copies of the box for this step layered one on top of the other, as you may need to perform this step multiple times to generalize the algorithm properly.</p> <p>One of the examples of an algorithm that we mentioned early in this chapter was determining if a number is prime. If you were trying to write a function to determine if a number is prime, your first step would be to pick a number and figure out if it is prime. Just saying “ok, I know 7 is prime,” is not of much use—you just used a fact you know and did not actually work out the problem. For a problem such as this one, which has a “yes or no” answer, we probably want to work at least one example that comes up with a “yes” answer, and one that comes up with a “no” answer.</p> <p>Another example would be if we wanted to write a program to compute <code class="docutils literal notranslate"><span class=pre >x</span></code> raised to the <code class="docutils literal notranslate"><span class=pre >y</span></code> power. To do Step 1, we would pick particular values for <code class="docutils literal notranslate"><span class=pre >x</span></code> and <code class="docutils literal notranslate"><span class=pre >y</span></code>, and work them by hand. We might try <code class="docutils literal notranslate"><span class=pre >x</span> <span class=pre >=</span> <span class=pre >3</span></code> and <code class="docutils literal notranslate"><span class=pre >y</span> <span class=pre >=</span> <span class=pre >4</span></code>, getting an answer of <code class="docutils literal notranslate"><span class=pre >3^4</span> <span class=pre >=</span> <span class=pre >81</span></code>.</p> <p>If you get stuck at this step, it typically means one of two things. The first case is that the problem is ill-specified—it is not clear what you are supposed to do. In such a situation, you must resolve how the problem should be solved before proceeding. In the case of a classroom setting, this resolution may require asking your professor or TA for more details. In an industrial setting, asking your technical lead or customer may be required. If you are solving a problem of your own creation, you may need to think harder about what the right answers should be and refine your definition of the problem.</p> <p>The second case where Step 1 is difficult is when you lack domain knowledge—the knowledge of the particular field or discipline the problem deals with. In our primality example, if you did not remember the definition of a prime number, that would be an example of lacking domain knowledge—the problem domain is mathematics, and you are lacking in math knowledge. No amount of programming expertise nor effort (“working harder”) will overcome this lack of domain knowledge. Instead, you must consult a source of domain expertise—a math textbook, website, or expert. Once you have the correct domain knowledge, you can proceed with solving your instance of the problem. Note that domain knowledge may come from domains other than math. It can come from any field, as programming is useful for processing any sort of information.</p> <p>Sometimes, domain knowledge may come from particular fields of computer science or engineering. For example, if you intend to write a program that determines the meaning of English text, the relevant domain field is actually a sub-field of computer science, called Natural Language Processing. Here the domain knowledge would be the specific techniques developed to write programs that deal with natural language. A source of domain knowledge on English (an English professor or textbook) is unlikely to contain such information.</p> </section> <section id="Step-2:-Write-Down-What-You-Just-Did"> <h2 id="Step-2:-Write-Down-What-You-Just-Did">Step 2: Write Down What You Just Did<a class=headerlink  href="#Step-2:-Write-Down-What-You-Just-Did" title="Link to this heading">¶</a></h2> <p>For this step, you must think about what you did to solve the problem, and write down the steps to solve that particular instance. Another way to think about this step, is to write down a clear set of instructions that anyone else could follow to reproduce your answer for the particular problem instance that you just solved. If you do multiple instances in Step 1, you will repeat Step 2 multiple times as well, once for each instance you did in Step 1. If an instruction is somewhat complex, that is all right, as long as the instruction has a clear meaning—later, we will turn these complex steps into their own programming problems, which will get solved separately.</p> <p>The difficult part of Step 2 is thinking about exactly what you did to accomplish the problem. The difficulty here is that it is very easy to mentally gloss over small details, “easy” steps, or things that you do implicitly. This difficulty is best illustrated by the peanut butter and jelly exercise we mentioned earlier. Implicit assumptions about what to do, or relying on common sense lead to imprecise or omitted steps. The computer will not fill in any steps you omit, thus you must be careful to think through all the details.</p> <p>Returning to our example of computing x to the y, we might write down the following steps for <code class="docutils literal notranslate"><span class=pre >x</span> <span class=pre >=</span> <span class=pre >3</span></code> and <code class="docutils literal notranslate"><span class=pre >y</span> <span class=pre >=</span> <span class=pre >4</span></code>:</p> <div class="highlight-none notranslate"><div class=highlight ><pre><span></span>Multiply 3 by 3
 - You get 9
Multiply 3 by 9
 - You get 27
Multiply 3 by 27
 - You get 81
81 is your answer.
</pre></div> </div> <p>The steps are very precise—and leave nothing to guess work. Anyone who can perform basic arithmetic can follow these steps to get the right answer. Computers are very good at arithmetic, so none of these steps is even complex enough to require splitting into a sub-problem.</p> </section> <section id="Step-3:-Generalize-Your-Steps"> <h2 id="Step-3:-Generalize-Your-Steps">Step 3: Generalize Your Steps<a class=headerlink  href="#Step-3:-Generalize-Your-Steps" title="Link to this heading">¶</a></h2> <p>Having solved one or more problems from the class we are interested in and written down the particular steps we executed to solve them, we are ready to try to generalize those steps into an algorithm. In our Step 2 steps, we solve particular instances, but now we need to find the pattern that allows us to solve the whole class.</p> <p>One way to think of this kind of generalization as a social scientist is that you are moving from writing rules that work for <em>a</em> case in your data (say, one observation) to a set of rules that you know will work for <em>all</em> observations in your data.</p> <p>This generalization typically requires two activities. First, we must take particular values that we used and replace them with mathematical expressions of the parameters. Looking at our Step 2 steps for computing <code class="docutils literal notranslate"><span class=pre >3^4</span></code>, we would see that we are always multiplying <code class="docutils literal notranslate"><span class=pre >3</span></code> by something in each step. In the more general case, we will not always use 3—we are using 3 specifically because it is the value that we picked for <code class="docutils literal notranslate"><span class=pre >x</span></code>. We can generalize this slightly by replacing this occurrence of <code class="docutils literal notranslate"><span class=pre >3</span></code> with <code class="docutils literal notranslate"><span class=pre >x</span></code>:</p> <div class="highlight-none notranslate"><div class=highlight ><pre><span></span>Multiply x by 3
 - You get 9
Multiply x by 9
 - You get 27
Multiply x by 27
 - You get 81
81 is your answer.
</pre></div> </div> <p>The second common way to generalize steps is to find repetition—the same step repeated over and over. Often the number of times that the pattern repeats will depend on the parameters. We must generalize how many times to do the steps, as well as what the steps are. Sometimes, we may find steps which are almost repetitive, in which case we may need to adjust our steps to make them exactly repetitive. In our <code class="docutils literal notranslate"><span class=pre >3^4</span></code> example, our multiplication steps are almost repetitive—both multiply <code class="docutils literal notranslate"><span class=pre >x</span></code> by “something,” but that “something” changes (<code class="docutils literal notranslate"><span class=pre >3</span></code> then <code class="docutils literal notranslate"><span class=pre >9</span></code> then 27). Examining the steps in more detail, we will see that the “something” we multiply is the answer from the previous step. We can then give it a name (and an initial value) to make all of these steps the same:</p> <div class="highlight-none notranslate"><div class=highlight ><pre><span></span>Start with n = 3
n = Multiply x by n
n = Multiply x by n
n = Multiply x by n
n is your answer
</pre></div> </div> <p>Now, we have the same exact step repeated three times. We can now contemplate how many times this step repeats as a function of <code class="docutils literal notranslate"><span class=pre >x</span></code> and/or <code class="docutils literal notranslate"><span class=pre >y</span></code>. We must be careful not to jump to the conclusion that it repeats <code class="docutils literal notranslate"><span class=pre >x</span></code> times because <code class="docutils literal notranslate"><span class=pre >x</span> <span class=pre >=</span> <span class=pre >3</span></code>—that is just a coincidence in this case. In this case, it repeats <code class="docutils literal notranslate"><span class=pre >y</span> <span class=pre >-</span> <span class=pre >1</span></code> times. The reason for this is that we need to multiply four 3s together, and we already have one in n at the start, so we need y - 1 more. This would lead to the following generalized steps:</p> <div class="highlight-none notranslate"><div class=highlight ><pre><span></span>Start with n = 3
Count up from 1 to y-1 (inclusive), for each number you count,
 - n = multiply x by n
n is your answer
</pre></div> </div> <p>We need to make one more generalization of a specific value to a function of the parameters. We start with <code class="docutils literal notranslate"><span class=pre >n</span> <span class=pre >=</span> <span class=pre >3</span></code>; however, we would not always want to start with <code class="docutils literal notranslate"><span class=pre >3</span></code>. In the general case, we would want to start with n = x:</p> <div class="highlight-none notranslate"><div class=highlight ><pre><span></span>Start with n = x
Count up from 1 to y-1 (inclusive), for each number you count,
 - n = multiply x by n
n is your answer
</pre></div> </div> <p>Sometimes you may find it difficult to see the pattern, making it hard to generalize the steps. When this happens, returning to Steps 1 and 2 may help. Doing more instances of the problem will provide more information for you to consider, possibly giving you insight into the patterns of your algorithm. This process is often referred to as writing ‘pseudo-code’, as you are working to design an algorithm programmatically with no particular target language. Nearly all programmers make use of this method to ensure their algorithm is correct before writing any actual code.</p> </section> <section id="Step-4:-Test-Your-Algorithm"> <h2 id="Step-4:-Test-Your-Algorithm">Step 4: Test Your Algorithm<a class=headerlink  href="#Step-4:-Test-Your-Algorithm" title="Link to this heading">¶</a></h2> <p>After Step 3, we have an algorithm that we think is right. However, it is entirely possible that we have messed up along the way. The primary purpose of Step 4 is to ensure our steps are actually right before we proceed. To accomplish this, we test our algorithm with different values of the parameters than the ones we used to design our algorithm. We execute our algorithm by hand and compare the answer it obtains to the right answer. If they differ, then we know our algorithm is wrong. The more test cases (values of parameters) we use, the more confident we can become that our algorithm is correct. Unfortunately, it is impossible to ensure that our algorithm is correct by testing. The only way to be completely sure that your algorithm is correct is to formally prove its correctness (using a mathematical proof), which is beyond the scope of this course.</p> <p>One common type of mistake is mis-generalizing in Step 3. As we just discussed, one might think that the steps repeated x times because <code class="docutils literal notranslate"><span class=pre >x</span> <span class=pre >=</span> <span class=pre >3</span></code> and the steps repeated 3 times. If we had written that down in Step 3, our algorithm would only work when <code class="docutils literal notranslate"><span class=pre >x</span> <span class=pre >=</span> <span class=pre >y</span> <span class=pre >–</span> <span class=pre >1</span></code>; otherwise we would count the wrong number of times and get the wrong answer. If that were the case, we would hopefully detect the problem by testing our algorithm by hand in Step 4. When we detect such a problem, we must go back and re-examine the generalizations we made in Step 3. Often, this is best accomplished by returning to Steps 1 and 2 for whatever test case exposed the problem. Re-doing Steps 1 and 2 will give you a concrete set of steps to generalize differently. You can then find where the generalization you came up with before is wrong, and revise it accordingly.</p> <p>Another common type of mistake is that there are cases we did not consider in designing our algorithm. In fact, in our <code class="docutils literal notranslate"><span class=pre >x^y</span></code> example, we did not consider what happens when <code class="docutils literal notranslate"><span class=pre >y</span> <span class=pre >=</span> <span class=pre >0</span></code>, and our algorithm handles this case incorrectly. If you execute the algorithm by hand with <code class="docutils literal notranslate"><span class=pre >x</span> <span class=pre >=</span> <span class=pre >2</span></code>, <code class="docutils literal notranslate"><span class=pre >y</span> <span class=pre >=</span> <span class=pre >0</span></code>, you should get <code class="docutils literal notranslate"><span class=pre >2^0=1</span></code>; however, you will get an answer of 2. Specifically, you will start with n = x = 2. We would then try to count up from <code class="docutils literal notranslate"><span class=pre >1</span></code> to <code class="docutils literal notranslate"><span class=pre >0</span> <span class=pre >–</span> <span class=pre >1</span> <span class=pre >=</span> <span class=pre >–1</span></code>, of which there are no numbers, so we would be done counting right away. We would then give back n (which is <code class="docutils literal notranslate"><span class=pre >2</span></code>) as our answer.</p> <p>To fix our algorithm, we would go back and revisit Steps 1 and 2 for the case that failed (x = 2, y = 0). This case is a bit tricky since we just know that the answer is 1 without doing any work (x^0=1 for any x). The fact that the answer requires no work makes Step 2 a little different—we just give an answer of 1. While this simplicity may seem nice, it actually makes it a little more difficult to incorporate it into our generalized steps. We might be tempted to write generalized steps like these:</p> <div class="highlight-none notranslate"><div class=highlight ><pre><span></span>If y is 0 then
 - 1 is your answer
Otherwise:
 - Start with n = x
 - Count up from 1 to y-1 (inclusive), for each number you count,
   - n = Multiply x by n
 - n is your answer
</pre></div> </div> <p>These steps check explicitly for the case that gave us a problem (y = 0), give the right answer for that case, then perform the more general algorithm. For some problems, there may be corner cases which require this sort of special attention. However, for this problem, we can do better. Note that if you were unable to see the better solution and were to take the above approach, it is not wrong per se, but it is not the best solution.</p> <p>Instead, a better approach would be to realize that if we count no times, we need an answer of 1, so we should start n at 1 instead of at x. In doing so, we need to count 1 more time (to y instead of to y – 1)—to multiply by x one more time:</p> <div class="highlight-none notranslate"><div class=highlight ><pre><span></span>Start with n = 1
Count up from 1 to y (inclusive), for each number you count,
 - n = Multiply x by n
n is your answer
</pre></div> </div> <p>Whenever we detect problems with our algorithm in Step 4, we typically want to return to Steps 1 and 2 to get more information to generalize from. Sometimes, we may see the problem right away (e.g., if we made a trivial arithmetic mistake, or if executing the problematic test case by hand gives us insight into the correct generalization). If we see how to fix the problem, it is fine to fix it right away without redoing Steps 1 and 2, but if you are stuck, you should redo those steps until you find a solution. Whatever approach you take to fixing your algorithm, you should re-test it with all the test cases you have already used, as well as some new ones.</p> <p>Determining good test cases is an important skill that improves with practice. For testing in Step 4, you will want to test with cases which at least produce a few different answers (e.g., if your algorithm has a “yes” or “no” answer, you should test with parameters which produce both “yes” and “no”). You should also test any corner cases—cases where the behavior may be different from the more general cases. Whenever you have conditional decisions (including limits on where to count), you should test potential corner cases right around the boundaries of these conditions. For example, if your algorithm makes a decision based on whether or not <code class="docutils literal notranslate"><span class=pre >x</span> <span class=pre >&lt;</span> <span class=pre >3</span></code> , you might want to test with <code class="docutils literal notranslate"><span class=pre >x</span> <span class=pre >=</span> <span class=pre >2</span></code>, <code class="docutils literal notranslate"><span class=pre >x</span> <span class=pre >=</span> <span class=pre >3</span></code>, and <code class="docutils literal notranslate"><span class=pre >x</span> <span class=pre >=</span> <span class=pre >4</span></code>. You can limit your “pencil and paper” testing somewhat, since you will do more testing on the actual code once you have written it.</p> <p>Now that you’ve read a description of this process, <a class="reference external" href="https://warpwire.duke.edu/w/icQFAA/">you can watch it in practice here (will require Duke login)</a></p> </section> </section> </article> </div> </div> </main> </div> <footer class=md-footer > <div class=md-footer-nav > <nav class="md-footer-nav__inner md-grid"> </a> </nav> </div> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class=md-footer-copyright > <div class=md-footer-copyright__highlight > &#169; Copyright 2024, Nick Eubank. </div> Created using <a href="http://www.sphinx-doc.org/">Sphinx</a> 7.2.6. and <a href="https://github.com/bashtage/sphinx-material/">Material for Sphinx</a> </div> </div> </div> </footer> <script src="_static/javascripts/application.js"></script> <script>app.initialize({version: "1.0.4", url: {base: ".."}})</script>