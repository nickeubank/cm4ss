{
 "cells": [
  {
   "cell_type": "markdown",
   "source": [
    "# Loops\n",
    "\n",
    "Until this point, the scripts we've been writing are quite straightforward: each line of code runs in sequence, one after another. Moreover, everything we want R to do, we have to write out by hand.\n",
    "\n",
    "In this lesson, we'll learn about loops -- a programming structure ideal for getting R to do LOTS of work with very little code. \n",
    "\n",
    "The basic idea of a loop is that in situations where you want R to do lots of very similar things, we can decompose our code into (a) generic code we want to run over and over, and (b) an input to that code that changes each time we repeat the generic code.\n",
    "\n",
    "Let's start with a simple example -- suppose I wanted to thank my TAs and everyone in class for a great bootcamp.I *could* type it out with:"
   ],
   "metadata": {}
  },
  {
   "cell_type": "markdown",
   "source": [
    "```r\n",
    "print(\"Happy Birthday Yi!\")\n",
    "print(\"Happy Birthday Zoe!\")\n",
    "print(\"Happy Birthday Ishani!\")\n",
    "print(\"Happy Birthday Kelly!\")\n",
    "...\n",
    "```\n",
    "etc. But that'd take FOREVER! Moreover, it's easy to see that most of what I'm typing out is exactly the same on every line. If only there were some way to leverage that information...\n",
    "\n",
    "Enter the loop!\n",
    "\n",
    "## The For-Loop\n",
    "\n",
    "The most basic loop is called a for-loop, and it loops over a collection of items, doing the loop once per item in the collection. \n",
    "\n",
    "In this case, our collection would be a vector with the names of all the students in the class. I won't make you look at the full list, though, so here's a little toy vector:"
   ],
   "metadata": {}
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "source": [
    "names <- c(\"Yi\", \"Zoe\", \"Ishani\", \"Kelly\")"
   ],
   "outputs": [],
   "metadata": {}
  },
  {
   "cell_type": "markdown",
   "source": [
    "Then we need to write out a for-loop, which looks like this:\n",
    "\n",
    "```r\n",
    "for(i in names) {\n",
    "    [code to repeat here]\n",
    "}\n",
    "```\n",
    "\n",
    "The way this loop works is that it iterates over the names in `names`, and each time it reaches a new name, it sets `i` to equal that name, then runs the code in the middle. For example, I could print all the names like this:"
   ],
   "metadata": {}
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "source": [
    "for (i in names) {\n",
    "    print(i)\n",
    "}"
   ],
   "outputs": [
    {
     "output_type": "stream",
     "name": "stdout",
     "text": [
      "[1] \"Yi\"\n",
      "[1] \"Zoe\"\n",
      "[1] \"Ishani\"\n",
      "[1] \"Kelly\"\n"
     ]
    }
   ],
   "metadata": {}
  },
  {
   "cell_type": "markdown",
   "source": [
    "But of course, we usually don't just want to print `i`, we want to use it. So let's try and thank everyone in the class with a loop. \n",
    "\n",
    "Before we write code inside our loop, though, we'll start by testing our code *outside* the loop to make it easier to troubleshoot, setting `i <- names[1]` by hand at the top to practice:"
   ],
   "metadata": {}
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "source": [
    "# Set `i` to first entry in `names`\n",
    "# When we put this inside the loop,\n",
    "# this will be done automatically by the loop\n",
    "i <- names[1]\n",
    "\n",
    "# Now write the code you want to put in your loop.\n",
    "message <- paste0(\"Thank you \", i, \" for a great class! \")\n",
    "print(message)"
   ],
   "outputs": [
    {
     "output_type": "stream",
     "name": "stdout",
     "text": [
      "[1] \"Thank you Yi for a great class! \"\n"
     ]
    }
   ],
   "metadata": {}
  },
  {
   "cell_type": "markdown",
   "source": [
    "If you haven't seen `paste0()` before, it's a function that takes characters and concatenates them (sticks them together). (There's also a function called `paste()` that does the same thing but also adds a space between entries). \n",
    "\n",
    "OK, so now that we've got working code to put in the middle, we can move it into our loop:"
   ],
   "metadata": {}
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "source": [
    "for (i in names) {\n",
    "    message <- paste0(\"Thank you \", i,\n",
    "                      \" for a great class! \")\n",
    "    print(message)\n",
    "}\n",
    "\n",
    "print(\"OK, bye now!\")"
   ],
   "outputs": [
    {
     "output_type": "stream",
     "name": "stdout",
     "text": [
      "[1] \"Thank you Yi for a great class! \"\n",
      "[1] \"Thank you Zoe for a great class! \"\n",
      "[1] \"Thank you Ishani for a great class! \"\n",
      "[1] \"Thank you Kelly for a great class! \"\n",
      "[1] \"OK, bye now!\"\n"
     ]
    }
   ],
   "metadata": {}
  },
  {
   "cell_type": "markdown",
   "source": [
    "A few things to note about this:\n",
    "\n",
    "- When developing the code to go into our loop, we started by assigning one of our names to `i`. In the real loop, we don't do that because it's done automatically at the top of the loop. \n",
    "- Remember how `print()` always seemed pointless, since you could always just type the name of a variable to see its value? Well that trick doesn't work in loops, which is why we need a tool like `print()`. \n",
    "- I also added a print statement at the end of my code -- as you can see, when the loop has iterated over all the values in `names`, R just moves on and runs the next command it sees. "
   ],
   "metadata": {}
  },
  {
   "cell_type": "markdown",
   "source": [
    "OK, let's take a moment to diagram what's happening here just to make sure everything is clear. For length, though, we'll shorten our name vector to just have Yi and Zoe. \n",
    "\n",
    "![loop1](images/loop1.png)\n",
    "\n",
    "![loop2](images/loop2.png)\n",
    "\n",
    "![loop3](images/loop3.png)\n",
    "\n",
    "![loop4](images/loop4.png)\n",
    "\n",
    "![loop5](images/loop5.png)\n",
    "\n",
    "![loop6](images/loop6.png)\n",
    "\n",
    "![loop7](images/loop7.png)"
   ],
   "metadata": {}
  },
  {
   "cell_type": "markdown",
   "source": [
    "## Building a Loop\n",
    "\n",
    "As noted above, the way to write a loop usually isn't just to write a loop -- troubleshooting code inside a loop is much harder than troubleshooting code that isn't in the loop because you can't run your code one line at a time if it is inside the loop. So when you're writing a loop, I recommend following the following steps:\n",
    "\n",
    "1. Write the first line of your loop. This will help you visualize what you're looping over and what your looping variable (e.g. `i` in the example above) will be. \n",
    "2. Write the code that you want to put inside your loop on its own. So that it runs the same way it will eventually run inside the loop, define your looping variable (`i`) to be equal to the first entry in the vector you're looping over (e.g. `i <- names[1]`). In that way the code you're writing will have access to the same variable that it will have later.\n",
    "3. Move the code you have written separately into the loop (without that initial assignment `i <- names[1]`, obviously). \n",
    "4. If you have problems, put `print()` statements inside your loop to give you information about what's going on."
   ],
   "metadata": {}
  },
  {
   "cell_type": "markdown",
   "source": [
    "## Other For-Loop Idioms\n",
    "\n",
    "There are couple common patterns with for loops to be aware of. Above, we saw how we can loop over vector of predefined values, but another common idiom to be aware of is looping over a vector created with the `1:N` operator (or the `seq()`) operator. For example, if I have a for loop that I want to run 5 times, I could write:"
   ],
   "metadata": {}
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "source": [
    "for (i in 1:5) {\n",
    "    print(i)\n",
    "}"
   ],
   "outputs": [
    {
     "output_type": "stream",
     "name": "stdout",
     "text": [
      "[1] 1\n",
      "[1] 2\n",
      "[1] 3\n",
      "[1] 4\n",
      "[1] 5\n"
     ]
    }
   ],
   "metadata": {}
  },
  {
   "cell_type": "markdown",
   "source": [
    "## If / Else"
   ],
   "metadata": {}
  },
  {
   "cell_type": "markdown",
   "source": [
    "## While Loops"
   ],
   "metadata": {}
  },
  {
   "cell_type": "markdown",
   "source": [
    "## Loops and the Tidyverse\n",
    "\n",
    "As you may recall from our discussion of dplyr and the tidyverse, most functions in the tidyverse use a form of nonstandard evaluation within their functions -- namely, text appearing within a function is not interpreted as the name of a variable, but as explicit data.\n",
    "\n",
    "This becomes important when writing loops because in loops, we need to use variables!\n",
    "\n",
    "To get around this, with tidyverse functions we can wrap our text in `.data[[]]` to ensure it's interpreted as a variable and not a literal value. For example:"
   ],
   "metadata": {}
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "source": [
    "for (n in "
   ],
   "outputs": [],
   "metadata": {}
  },
  {
   "cell_type": "markdown",
   "source": [
    "## Don't Loop Over Big Vectors / Data \n",
    "\n",
    "Finally, a super super important note about loops:"
   ],
   "metadata": {}
  },
  {
   "cell_type": "markdown",
   "source": [
    "\n",
    "**CAUTION:** Do not loop over your dataset rows\n",
    "\n",
    "Loops are powerful, but one thing you almost never want to do is loop over the rows of your dataset. The reason is that looping is **much** slower than doing an operation using vector math (a practice called \"vectorization\"). "
   ],
   "metadata": {}
  },
  {
   "cell_type": "markdown",
   "source": [
    "To illustrate, suppose I want to add up two vectors, each with 1,000,000 entries, and time the operation:"
   ],
   "metadata": {}
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "source": [
    "# Two random variables:\n",
    "v1 <- rnorm(1000000)\n",
    "v2 <- rnorm(1000000)\n",
    "\n",
    "# add up with vector math:\n",
    "\n",
    "# Record the current time\n",
    "start <- proc.time()\n",
    "\n",
    "# Multiply entries in two vectors\n",
    "v1 <- v1 * v2\n",
    "\n",
    "# Record current time\n",
    "stop <- proc.time()\n",
    "\n",
    "# Measure how much time elapsed\n",
    "run_time_vector_addition <- stop - start\n",
    "run_time_vector_addition"
   ],
   "outputs": [
    {
     "output_type": "display_data",
     "data": {
      "text/plain": [
       "   user  system elapsed \n",
       "  0.004   0.000   0.004 "
      ]
     },
     "metadata": {}
    }
   ],
   "metadata": {}
  },
  {
   "cell_type": "markdown",
   "source": [
    "Note I have to put them in a function to do it because of how "
   ],
   "metadata": {}
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "source": [
    "# Now add them up in a loop.\n",
    "\n",
    "# Record the current time\n",
    "start <- proc.time()\n",
    "\n",
    "# Multiplying entries in a loop\n",
    "for (i in 1:1000000) {\n",
    "    v1[i] <- v1[i] * v2[i]\n",
    "}\n",
    "\n",
    "# Record current time\n",
    "stop <- proc.time()\n",
    "\n",
    "# Measure how much time elapsed\n",
    "run_time_loop_addition <- stop - start\n",
    "run_time_loop_addition"
   ],
   "outputs": [
    {
     "output_type": "display_data",
     "data": {
      "text/plain": [
       "   user  system elapsed \n",
       "  0.081   0.004   0.086 "
      ]
     },
     "metadata": {}
    }
   ],
   "metadata": {}
  },
  {
   "cell_type": "code",
   "execution_count": 33,
   "source": [
    "# Looped took about this many time longer:\n",
    "\n",
    "round(run_time_loop_addition[\"elapsed\"] / run_time_vector_addition[\"elapsed\"], 2)\n"
   ],
   "outputs": [
    {
     "output_type": "display_data",
     "data": {
      "text/plain": [
       "elapsed \n",
       "   21.5 "
      ],
      "text/markdown": [
       "**elapsed:** 21.5"
      ],
      "text/latex": [
       "\\textbf{elapsed:} 21.5"
      ],
      "text/html": [
       "<strong>elapsed:</strong> 21.5"
      ]
     },
     "metadata": {}
    }
   ],
   "metadata": {}
  },
  {
   "cell_type": "markdown",
   "source": [
    "So... yeah, over an order of magnitude slower. Don't do it. \n",
    "\n",
    "Of course, in this example, the actual manipulations we're doing are small enough that in absolute terms both operations are fast enough that it wouldn't really matter which one you choose, but as you get into more complicated data manipulations, this kind of 10x speed difference (and often the differences are much much larger, on the order of 100x or more) can be the difference between your code running in a couple of seconds and versus a couple of hours (or the difference between running in a couple minutes and taking a couple days).\n",
    "\n",
    "(If you want to know why, I have an explanation for the [same phenomenon in Python here](https://www.practicaldatascience.org/html/performance_understanding.html). The examples have Python code, but the principles are the same.)\n",
    "\n",
    "So what should you do instead? You always want to write *vectorized code*, meaning code that operates on vectors as a whole rather than on the entries of a vector one at a time."
   ],
   "metadata": {}
  },
  {
   "cell_type": "markdown",
   "source": [
    "## Exercises\n",
    "\n",
    "\n",
    "1. Use a for loop to take the square root of each value in the following \n",
    "vector: `vec1 <- c(4, 9, 81, 100, 1000, 10^6)`. Save the results to a new \n",
    "vector called `vec2`. \n",
    "\n",
    "2. Monte Carlo Simulation: Imagine that the values in the vector `pop`\n",
    "below represent vote shares for a presidential candidate across the\n",
    "3,144 counties in the United States. If we were to take a sample of 50\n",
    "counties and estimate mean support for the presidential candidate,\n",
    "would we, on average, estimate the vote share across all counties\n",
    "accurately? (Don't worry about the fact that we really should be\n",
    "weighing counties by their population size to estimate overall\n",
    "support.) Draw 10,000 samples of 50 counties from `pop` and estimate\n",
    "mean support for each sample, saving each mean estimate into a vector\n",
    "called `smpl_means`. How does the mean of the sample means compare to \n",
    "the population mean? Do we, on average, do a good job of estimating the \n",
    "population mean? \n",
    "\n",
    "<div class=\"indent\">"
   ],
   "metadata": {
    "lines_to_next_cell": 0
   }
  }
 ],
 "metadata": {
  "jupytext": {
   "cell_metadata_filter": "echo,-all",
   "main_language": "R",
   "notebook_metadata_filter": "-all"
  },
  "language_info": {
   "name": "R",
   "codemirror_mode": "r",
   "pygments_lexer": "r",
   "mimetype": "text/x-r-source",
   "file_extension": ".r",
   "version": "4.1.0"
  },
  "kernelspec": {
   "name": "ir",
   "display_name": "R",
   "language": "R"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}